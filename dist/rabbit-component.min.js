!function (e, t) { "use strict"; "object" == typeof module && "object" == typeof module.exports ? module.exports == e.document && t(e) : t(e) }("undefined" != typeof window ? window : this, function (e) { "use strict"; const t = { nodeTypeAttribue: ["rabbit-text", "rabbit-html", "rabbit-for"], ifAttribute: "if", addClassAttribute: "+class", nodeType: { root: 0, text: 1, html: 2, array: 3, item: 4, unknown: 5 }, eventAttributePrefix: "on:", eventNames: ["click", "change"] }; var n = function () { var e = Array.prototype, n = Object.create(e); return ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(i => { var l = e[i]; !function (e, t, n) { Object.defineProperty(e, t, { value: n, enumerable: !1, configurable: !0 }) }(n, i, function () { var e = arguments, n = (arguments.length, l.apply(this, e)), a = this.observers; return "push" == i ? a.forEach(n => { let r = [], i = n.target; for (let n = 0; n < e.length; n++)r.push(new s(i.element.cloneNode(!0), t.nodeType.item, e[n], i)); l.apply(n.target.children, r), o(n.component, r) }) : "unshift" == i ? a.forEach(n => { var r = []; let i = n.target; for (let n = 0; n < e.length; n++)r.push(new s(i.element.cloneNode(!0), t.nodeType.item, e[n], i)); l.apply(n.target.children, r), o(n.component, r) }) : "splice" == i ? a.forEach(n => { let i = [], a = []; for (let n = 0, r = e.length; n < r; n++)if (n > 2) { let r = new s(node.element.cloneNode(!0), t.nodeType.item, e[n], node); i.push(r), a.push(r) } else i.push(e[n]); o(n.component, a), r(l.apply(n.target.children, i)) }) : "pop" == i ? a.forEach(t => { let n = []; n.push(l.apply(t.target.children, e)), r(n) }) : "shift" == i ? a.forEach(t => { let n = []; n.push(l.apply(t.target.children, e)), r(n) }) : "sort" == i ? a.forEach(t => { l.apply(t.target.children, [(n, r) => e[0].apply(t.target.children, [n.model, r.model])]) }) : "reverse" == i && a.forEach(t => { l.apply(t.target.children, e) }), function (e, t, n) { e.forEach(e => { let t = e.target.children; for (let e = 0, n = t.length; e < n; e++)t[e].itemIndex = e; e.component.sortItemNodes(e.target) }) }(a), n }) }), n }(); function r(e) { e.forEach(e => { e.element.parentElement.removeChild(e.element) }) } function o(e, t) { t.forEach(t => { e.mountBunch(t), e.renderBunch(t) }) } function i(e) { this.template = document.querySelector(e), null == this.template && console.error("rabit can not find the template from the selector:'" + e + "', please check it."), this.tree = {}, this.method = {}, this.data = {} } function l(e, t) { let n = e.getAttribute(t); return null == n ? null : n } function s(e, t, n, r) { this.element = e, this.type = t, this.model = n, this.parent = r || null, this.children = [], this.classer = null, this.attributes = [], this.active = !0, this.events = [], this.itemIndexName = null, this.indexName = null, this.parentElement = null } function a(e, t) { this.handler = e, this.node = t } function u(e, t, n) { this.model = e, this.node = t, this.reverse = n } function h(e) { var t = [], n = e.match(/{{(.+?)}}/g); return null == n ? null : (n.forEach(e => { t.push(f(e, 2)) }), t) } function c(e, t, n, r) { this.compare1 = e, this.compare2 = t, this.class1 = n, this.class2 = r } function p(e, t) { this.model = e, this.target = t, this.variable = null } function d(e, t, n, r) { this.name = e, this.variables = t, this.node = n, this.pattern = r } function m(e, t) { this.component = e, this.target = t } function f(e, t) { return 2 == e.length ? "" : (null == t && (t = 1), e.substr(t, e.length - 2 * t)) } i.prototype.mount = function (e, t) { this.data = e, this.methods = t || {}, this.mountTree(), this.renderTree() }, i.prototype.mountTree = function () { var e = this.template; this.tree.root = this.hangNode(null, e), this.mountBunch(this.tree.root) }, i.prototype.mountBunch = function (e, n) { if (null == n && (n = e.element), 0 != e.active) if (e.type != t.nodeType.array) for (let t = 0, r = n.children.length; t < r; t++) { let r = this.hangNode(e, n.children[t]); null === r ? this.mountBunch(e, n.children[t]) : this.mountBunch(r) } else this.mountItemNodes(e) }, i.prototype.mountItemNodes = function (e) { let n = e.model; null == n ? (console.error("please set the rabbit-for to an array type value"), console.error("if you want to prevent mounting,please put it in an if element which detemine if the array exists")) : Array.isArray(n) || console.error("please set the rabbit-for to an array type value"); let r = e.element; for (let o = 0, i = n.length; o < i; o++) { let i = r.cloneNode(!0), l = this.hangNode(e, i, n[o]); null == l ? l = new s(i, t.nodeType.item, n[o], e) : l.type = t.nodeType.item, l.itemIndex = o, 0 != l.active && (this.mountBunch(l), e.children.push(l)) } }, i.prototype.hangNode = function (e, n, r) { var o = null, i = n.attributes, l = []; null != r && (o = new s(n, t.nodeType.item, r, e)), null == e && (e = new s, o = new s(n, t.nodeType.unknown, null, null)); var c = !1; for (let e = 0, t = i.length; e < t; e++)"rabbit-for" == i[e].name && (c = !0); if (c) return this.hangArrayNode(e, n); for (let r = 0, c = i.length; r < c; r++) { let c = i[r], f = t.nodeTypeAttribue.indexOf(c.name), y = !1; if (-1 !== f) { y = !0; let r = null; 0 == f ? r = t.nodeType.text : 1 == f && (r = t.nodeType.html), null === o && (o = new s(n, r, null, e)), this.setWatcher(o, c.value, o), e.children.push(o) } else if (c.name == t.ifAttribute) { y = !0, null === o && (o = new s(n, t.nodeType.unknown, null, e), e.children.push(o)); let r = !1; "!" == c.value[0] && (r = !0); let i = new u(null, o, r), l = c.value; r && (l = l.slice(1)), this.setWatcher(o, l, i) } else if (c.name == t.addClassAttribute) y = !0, null === o && (o = new s(n, t.nodeType.unknown, null, e), e.children.push(o)), this.createAddClass(c, o); else if (0 == c.name.indexOf(t.eventAttributePrefix)) { y = !0, null === o && (o = new s(n, t.nodeType.unknown, null, e), e.children.push(o)); let r = c.name.substr(t.eventAttributePrefix.length); -1 == t.eventNames.indexOf(r) && console.error("rabbit can not identify your event:" + r); let i = c.value; i in this.methods || console.error("the methods you passed in do not contain method named " + i); var m = new a(this.methods[i], o); m.mount(), o.events.push(m) } else if (":" == c.name[0]) { y = !0, null === o && (o = new s(n, t.nodeType.unknown, null, e), e.children.push(o)); let r = c.name.substr(1, c.name.length - 1), i = c.value, l = new d(r, null, o, i), a = h(i); null == a && console.error("the varibles in attribute must be wrapped by the {{}},please check " + c.name); let u = []; a.forEach(e => { var t = new p(null, l); t.name = e, this.setWatcher(o, e, t), u.push(t) }), l.variables = u, o.attributes.push(l) } y && l.push(c.name) } return l.forEach(e => { n.removeAttribute(e) }), o }, i.prototype.sortItemNodes = function (e) { e.children.forEach(t => { e.parentElement.insertBefore(t.element, e.refElement) }) }, i.prototype.hangArrayNode = function (e, n) { var r = new s(n, t.nodeType.array, null, e), o = l(n, "rabbit-key"); null == o && console.error("please add 'rabbit-key' to identity the name of item in array"), n.removeAttribute("rabbit-key"), r.itemName = o; var i = l(n, "rabbit-index"); null != i && (n.removeAttribute("rabbit-index"), r.itemIndexName = i), this.setWatcher(r, l(n, "rabbit-for"), r), n.removeAttribute(t.nodeTypeAttribue[2]), r.parentElement = n.parentElement; var a = document.createElement("p"); return a.style.display = "none", a.classList.add("rabbit-reference"), r.parentElement.insertBefore(a, n), r.refElement = a, r.parentElement.removeChild(n), e.children.push(r), r }, i.prototype.createAddClass = function (e, t) { let n = e.value, r = n.split(","); 4 != r.length && console.error("your +class " + n + " must have something wrong"); var o = new c(null, null, f(r[2]), f(r[3])), i = new p(null, o); this.setWatcher(t, r[0], i); let l = r[1]; var s = new p(null, o); "'" == l[0] && "'" == l[l.length - 1] ? s.model = f(l) : this.setWatcher(t, l, s), o.compare1 = i, o.compare2 = s, t.classer = o }, i.prototype.renderTree = function () { var e = this.tree.root; this.renderBunch(e) }, i.prototype.renderBunch = function (e) { !1 !== e.active ? (e.element.style.display = "", e.type == t.nodeType.text ? e.element.innerText = e.model : e.type == t.nodeType.html ? e.element.innerHTML = e.model : e.type == t.nodeType.item && e.parent.parentElement.insertBefore(e.element, e.refElement), this.renderAttributes(e), e.children.forEach(e => { this.renderBunch(e) })) : e.element.style.display = "none" }, i.prototype.renderAttributes = function (e) { for (let t = 0, n = e.attributes.length; t < n; t++) { let n = e.attributes[t], r = n.pattern; n.variables.forEach(e => { r = n.pattern.replace("{{" + e.name + "}}", e.model, "g") }), e.element.setAttribute(n.name, r) } if (null != e.classer) { var t = e.classer; t.compare1.model == t.compare2.model ? (t.class1 && e.element.classList.add(t.class1), t.class2 && e.element.classList.remove(t.class2)) : (t.class2 && e.element.classList.add(t.class2), t.class1 && e.element.classList.remove(t.class1)) } }, i.prototype.setWatcher = function (e, t, n) { var r = this.findDomains(e, t, n), o = r.startPoints, i = r.startPointDomains; if (!Array.isArray(i)) return n.model = i, i; var l = t.split("."), s = null; for (let e = o.length - 1; e >= 0; e--) { if (0 !== e && i[e] == l[0]) { s = o[e]; for (let e = 1, t = l.length; e < t; e++)e == t - 1 && this.defineReactive(s, l[t - 1], n), s = s[l[e]] } if (0 === e && null != o[e][l[0]]) { s = o[e]; for (let e = 0, t = l.length; e < t; e++)e == t - 1 && this.defineReactive(s, l[t - 1], n), s = s[l[e]] } } return null === s && console.error("the model of " + t + " is not defined"), n.model = s, n instanceof u && (n.node.active = !!s), s }, i.prototype.findDomains = function (e, n, r) { for (var o = [this.data], i = [null]; null != e;) { if (e.type == t.nodeType.item) { let t = e.parent.itemName; if (t == n) return { startPoints: o, startPointDomains: e.model }; if (e.parent.itemIndexName == n) return this.defineReactive(e, "itemIndex", r), { startPoints: o, startPointDomains: e.itemIndex }; o.push(e.model), i.push(t) } e = e.parent } return { startPoints: o, startPointDomains: i } }, i.prototype.defineReactive = function (e, t, r) { var o = Object.getOwnPropertyDescriptor(e, t); if (o && !1 === o.configurable) return; let i = e[t]; if (Array.isArray(i)) return i.__proto__ = n, void (void 0 === i.observers ? (i.observers = [new m(this, r)], Object.defineProperty(i, "observers", { enumerable: !1 })) : i.observers.push(new m(this, r))); void 0 === e.observers ? (e.observers = {}, e.observers[t] = [new m(this, r)], Object.defineProperty(e, "observers", { enumerable: !1 })) : null == e.observers[t] ? e.observers[t] = [new m(this, r)] : e.observers[t].push(new m(this, r)), Object.defineProperty(e, t, { enumerable: !0, configurable: !0, get: () => i, set(n) { i = n, e.observers[t].forEach(e => { var t = e.target, r = e.component; t.model = n, t instanceof s ? r.renderBunch(t) : t instanceof u ? t.run(n) : t instanceof d && r.renderAttributes(t.node) }) } }) }, a.prototype.mount = function () { this.node.element.addEventListener("click", this.handler) }, u.prototype.run = function (e) { var t = this.reverse ? !e : !!e; t != this.node.active && (this.node.active = t, 1 == t && component.mountBunch(this.node), component.renderBunch(this.node)) }; var y = {}; function b(e, t, n, r, o) { var i = new XMLHttpRequest; i.open(e, t, !0), i.onreadystatechange = function () { 4 == i.readyState && (200 == i.status || 304 == i.status ? null != r && r(this.response) : null != o && o(JSON.parse(this.response), this.status)) }, n && i.send(n) } y.get = function (e, t, n) { b("get", e, null, t, n) }, y.post = function (e, t, n, r) { b("post", e, t, n, r) }, y.patch = function (e, t, n, r) { b("patch", e, t, n, r) }, y.delete = function (e, t, n, r) { b("delete", e, t, n, r) }, y.put = function (e, t, n, r) { b("put", e, t, n, r) }, void 0 === e.rabbit && (e.rabbit = {}), e.rabbit.Component = i, e.rabbit.http = y });